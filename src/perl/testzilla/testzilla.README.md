Testzilla

What this is:

    Testzilla is a script that is designed to wade through the nasty bug gathering work from Bugzilla. Provided a query,
    Testzilla will mine the code from the bugs that are returned by the query. Testzilla looks for three languages, Fortran
    and C\C++.

Disclaimer:

    Testzilla isn't perfect, it's far from it. As much extra logic procedures I added, some things still get by. Since everyone
    codes in a different manor, and sometimes their styles vary more significantly than others, I could not catch everything.
    The logs should show which comments that Testzilla comes across in which it isn't sure if it did it correctly. However for C
    and C++ I was unable to do this as well. Basically, don't assume everything that comes out of here is correct. Debugging will
    still be needed, but the hours and hours of sifting and copy-pasting will be omitted.

For the curious:

    Fortran Logic & Known Bugs:

        The Fortran parser looks for a few things. The dictionary comprises of several keywords for the language itself and directives.
        It ignores case, and tracks white space. If a keyword is found (like program, module, etc). It begins adding the lines and any
        subsequent line to a queue. Once the end keyword is found (with matching white space, keyword type, and name {those last two are
        not always applicable} it stops adding to the queue and looks for anything else. If it finds something else, it checks to see if
        it is already declared (just like a compiler) and throws a warning; finishing the queue by writing to file, and moves on to the
        next bug. If none of that happens, and nothing else is found then it simply writes to file and moves on.

        The white space is important, it leads to my final logical search. If say someone wrote the word "module" in an English statement
        and it turned out that began a new line, the script will begin pulling in "code." This is bad. However the assumption is made:
        "If someone is talking about it, their writing about it" and if it finds the same declaration with identical white space, it scraps
        what is has found thinking it is gibberish and starts over at the new line it found.

        Lastly, it does look for Fortran headers, but only if they end with .fn.

    C\C++ Logic & Known Bugs:

        The C parser is much simpler. If an include is found it begins adding lines to the queue. Once it find and ending brace at the
        beginning of a line it will stop and look for an opening brace at the end of a line with words in front of it. Once found, it
        once again looks for the ending brace at the beginning of a line. If there are no includes, it still looks for the words with the
        open brace. However, some people don't but the curly brace on the same line as the function, to combat this obstacle the script remembers the
        previous line and if a lone open curly brace is found, it adds the previous line to the queue first.

        Additionally some people expand their code even more, going so far to do this:

        int
        main (int argc, char* argv[])
        {

        Which causes problems. To combat this, if any data type is found alone on a line the script just chucks it into the array. However
        it will not detect if the data type is user defined (such as classes, typedefs, and enums).

        Of course, this also looks for #pragma and throws it into the queue. On top of this, if it find any mention of .cpp it will convert
        the source file to .cpp. Else it defaults to .c.

        Lastly, it will pull in code that isn't real sometimes. If someone posts a small block of code that is incomplete but it has matching
        braces, then my code will pull it in. The C files need a little more look-see after this script runs.

File Explanation:

testzilla.pl    -   Main executable, can be ran as ./testzilla.pl. Use -? or -man for documentation

libs            -   Holds the modules that are necessary for Testzilla

bug.xml         -   Generated by testzilla, this is the XML dump of the results from the query

perl_xml.txt    -   Generated by testzilla, this is the dump of what is actually navigated by Perl

log.main        -   Generated by testzilla, this holds general information

log.del         -   Generated by testzilla, this holds information regarding what files were ignored or deleted

*_out           -   Output directories for tests

*_out.old       -   Output from previous execution. These are deleted after the 2nd run
